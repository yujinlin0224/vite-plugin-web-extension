{"version":3,"sources":["../src/index.ts","../src/plugins/manifest-loader-plugin.ts","../src/constants.ts","../src/logger.ts","../src/build/build-context.ts","../src/utils.ts","../src/plugins/labeled-step-plugin.ts","../src/plugins/multibuild-complete-plugin.ts","../src/plugins/bundle-tracker-plugin.ts","../src/build/getViteConfigsForInputs.ts","../src/plugins/hmr-rewrite-plugin.ts","../src/extension-runner/web-ext-runner.ts","../src/config.ts","../src/manifest-validation.ts","../src/csp.ts","../src/build/renderManifest.ts"],"sourcesContent":["import * as vite from \"vite\";\nimport { ResolvedOptions, UserOptions } from \"./options\";\nimport { manifestLoaderPlugin } from \"./plugins/manifest-loader-plugin\";\nimport fs from \"fs-extra\";\n\nexport { UserOptions as PluginOptions };\n\nexport default function webExtension(\n  options: UserOptions = {}\n): vite.PluginOption {\n  const internalOptions: ResolvedOptions = {\n    additionalInputs: options.additionalInputs ?? [],\n    disableAutoLaunch: options.disableAutoLaunch ?? false,\n    manifest: options.manifest ?? \"manifest.json\",\n    printSummary: options.printSummary ?? true,\n    skipManifestValidation: options.skipManifestValidation ?? false,\n    watchFilePaths: options.watchFilePaths ?? [],\n    browser: options.browser,\n    htmlViteConfig: options.htmlViteConfig,\n    scriptViteConfig: options.scriptViteConfig,\n    webExtConfig: options.webExtConfig,\n    verbose: process.argv.includes(\"-d\") || process.argv.includes(\"--debug\"),\n    disableColors:\n      process.env.CI === \"true\" || process.env.DISABLE_COLORS === \"true\", // TODO: document env var\n  };\n\n  return manifestLoaderPlugin(internalOptions);\n}\n\n/**\n * Helper function for `JSON.parse(fs.readFileSync(..., \"utf-8\"))`.\n */\nexport function readJsonFile(file: string): any {\n  return fs.readJsonSync(file);\n}\n","import * as vite from \"vite\";\nimport { ResolvedOptions, Manifest, ProjectPaths } from \"../options\";\nimport { createLogger } from \"../logger\";\nimport { MANIFEST_LOADER_PLUGIN_NAME } from \"../constants\";\nimport { BuildMode } from \"../build/BuildMode\";\nimport { createBuildContext } from \"../build/build-context\";\nimport {\n  defineNoRollupInput,\n  resolveBrowserTagsInObject,\n  getOutDir,\n  getPublicDir,\n  getRootDir,\n  colorizeFilename,\n} from \"../utils\";\nimport path from \"node:path\";\nimport fs from \"fs-extra\";\nimport { inspect } from \"node:util\";\nimport * as rollup from \"rollup\";\nimport type browser from \"webextension-polyfill\";\nimport { createWebExtRunner, ExtensionRunner } from \"../extension-runner\";\nimport { createManifestValidator } from \"../manifest-validation\";\nimport { ContentSecurityPolicy } from \"../csp\";\nimport { renderManifest } from \"../build/renderManifest\";\n\n/**\n * This plugin composes multiple Vite builds together into a single Vite build by calling the\n * `Vite.build` JS API inside the original build.\n *\n * The plugin itself configures just the manifest to be transformed and it starts the \"build\n * context\", where the rest of the build is performed.\n */\nexport function manifestLoaderPlugin(options: ResolvedOptions): vite.Plugin {\n  const noInput = defineNoRollupInput();\n  const logger = createLogger(options.verbose, options.disableColors);\n  const ctx = createBuildContext({ logger, pluginOptions: options });\n  const validateManifest = createManifestValidator({ logger });\n\n  let mode = BuildMode.BUILD;\n  let userConfig: vite.UserConfig;\n  let resolvedConfig: vite.ResolvedConfig;\n  let extensionRunner: ExtensionRunner;\n  let paths: ProjectPaths;\n  let isError = false;\n\n  /**\n   * Set the build mode based on how vite was ran/configured.\n   */\n  function configureBuildMode(config: vite.UserConfig, env: vite.ConfigEnv) {\n    if (env.command === \"serve\") {\n      logger.verbose(\"Dev mode\");\n      mode = BuildMode.DEV;\n    } else if (config.build?.watch) {\n      logger.verbose(\"Watch mode\");\n      mode = BuildMode.WATCH;\n    } else {\n      logger.verbose(\"Build mode\");\n      mode = BuildMode.BUILD;\n    }\n  }\n\n  /**\n   * Loads the manifest.json with it's browser template tags resolved, and the real source file\n   * extensions\n   */\n  async function loadManifest(): Promise<Manifest> {\n    let manifestTemplate: Manifest;\n    if (typeof options.manifest === \"function\") {\n      logger.verbose(\"Loading manifest from function\");\n      manifestTemplate = await options.manifest();\n    } else {\n      // Manifest string should be a path relative to the config.root\n      const manifestPath = path.resolve(paths.rootDir, options.manifest);\n      logger.verbose(\n        `Loading manifest from file @ ${manifestPath} (root: ${paths.rootDir})`\n      );\n      manifestTemplate = await fs.readJson(manifestPath);\n    }\n    logger.verbose(\n      \"Manifest template: \" + inspect(manifestTemplate, undefined, 5)\n    );\n\n    const resolvedManifest = resolveBrowserTagsInObject(\n      options.browser ?? \"chrome\",\n      manifestTemplate\n    );\n    logger.verbose(\"Manifest with entrypoints: \" + inspect(resolvedManifest));\n    return resolvedManifest;\n  }\n\n  async function openBrowser() {\n    logger.log(\"\\nOpening browser...\");\n    extensionRunner = createWebExtRunner({\n      pluginOptions: options,\n      paths,\n      logger,\n    });\n    await extensionRunner.openBrowser();\n    logger.log(\"Done!\");\n  }\n\n  return {\n    name: MANIFEST_LOADER_PLUGIN_NAME,\n\n    // Runs during: Build, dev, watch\n    async config(config, env) {\n      if (options.browser != null) {\n        logger.verbose(`Building for browser: ${options.browser}`);\n      }\n      configureBuildMode(config, env);\n      userConfig = config;\n\n      return vite.mergeConfig(\n        {\n          build: {\n            // Since this plugin schedules multiple builds, we can't let any of the builds empty the\n            // outDir. Instead, the plugin cleans up the outDir manually in `onBuildStart`\n            emptyOutDir: false,\n          },\n        },\n        // We only want to output the manifest.json, so we don't need an input.\n        noInput.config\n      );\n    },\n\n    // Runs during: Build, dev, watch\n    configResolved(config) {\n      resolvedConfig = config;\n      paths = {\n        rootDir: getRootDir(config),\n        outDir: getOutDir(config),\n        publicDir: getPublicDir(config),\n      };\n    },\n\n    // Runs during: Build, dev, watch\n    async buildStart() {\n      // Empty out directory\n      if (resolvedConfig.build.emptyOutDir) {\n        logger.verbose(\"Removing build.outDir...\");\n        await fs.rm(getOutDir(resolvedConfig), {\n          recursive: true,\n          force: true,\n        });\n      }\n\n      // Add watch files that trigger a full rebuild\n      options.watchFilePaths.forEach((file) => this.addWatchFile(file));\n      if (typeof options.manifest === \"string\") {\n        this.addWatchFile(path.resolve(paths.rootDir, options.manifest));\n      }\n\n      // Build\n      const manifestWithInputs = await loadManifest();\n      await ctx.rebuild({\n        paths,\n        userConfig,\n        resolvedConfig,\n        manifest: manifestWithInputs,\n        mode,\n        onSuccess: async () => {\n          if (extensionRunner) await extensionRunner.reload();\n        },\n      });\n\n      // Generate the manifest based on the output files\n      const finalManifest = renderManifest(\n        manifestWithInputs,\n        ctx.getBundles()\n      );\n\n      // Add permissions and CSP for the dev server\n      if (mode === BuildMode.DEV) {\n        applyDevServerCsp(finalManifest);\n      }\n\n      if (!options.skipManifestValidation) {\n        await validateManifest(finalManifest);\n      }\n      if (mode !== BuildMode.DEV) {\n        this.emitFile({\n          type: \"asset\",\n          source: JSON.stringify(finalManifest),\n          fileName: \"manifest.json\",\n          name: \"manifest.json\",\n        });\n      } else {\n        logger.log(\n          \"\\nWriting \\x1b[95mmanifest.json\\x1b[0m before starting dev server...\"\n        );\n        await fs.writeFile(\n          path.resolve(paths.outDir, \"manifest.json\"),\n          JSON.stringify(finalManifest),\n          \"utf8\"\n        );\n      }\n\n      await copyPublicDirToOutDir({ mode, paths });\n\n      // In dev mode, open up the browser immediately after the build context is finished with the\n      // first build.\n      if (mode === BuildMode.DEV) {\n        await openBrowser();\n      }\n    },\n\n    // Runs during: build, dev, watch\n    resolveId(id) {\n      return noInput.resolveId(id);\n    },\n\n    // Runs during: build, dev, watch\n    load(id) {\n      return noInput.load(id);\n    },\n\n    // Runs during: build, watch\n    buildEnd(err) {\n      isError = err != null;\n    },\n\n    // Runs during: build, watch\n    async closeBundle() {\n      if (isError || mode === BuildMode.BUILD || options.disableAutoLaunch) {\n        return;\n      }\n\n      await openBrowser();\n    },\n\n    // Runs during: build, watch\n    generateBundle(_, bundle) {\n      noInput.cleanupBundle(bundle);\n    },\n\n    // Runs during: watch\n    async watchChange(id) {\n      const relativePath = path.relative(paths.rootDir, id);\n      logger.log(\n        `\\n${colorizeFilename(relativePath)} changed, restarting browser`\n      );\n      await extensionRunner?.exit();\n    },\n  };\n}\n\n/**\n * Manually copy the public directory at the start of the build during dev/watch mode - vite does\n * this for us in build mode.\n */\nasync function copyPublicDirToOutDir({\n  mode,\n  paths,\n}: {\n  mode: BuildMode;\n  paths: ProjectPaths;\n}) {\n  if (\n    mode === BuildMode.BUILD ||\n    !paths.publicDir ||\n    !(await fs.pathExists(paths.publicDir))\n  ) {\n    return;\n  }\n\n  await fs.copy(paths.publicDir, paths.outDir);\n}\n\nasync function applyDevServerCsp(manifest: Manifest) {\n  manifest.permissions ??= [];\n  manifest.permissions.push(\"http://localhost/*\");\n\n  const csp = new ContentSecurityPolicy(\n    manifest.manifest_version === 3\n      ? manifest.content_security_policy?.extension_pages ??\n        \"script-src 'self' 'wasm-unsafe-eval'; object-src 'self';\" // default CSP for MV3\n      : manifest.content_security_policy ??\n        \"script-src 'self'; object-src 'self';\" // default CSP for MV2\n  );\n  csp.add(\"script-src\", \"http://localhost:*\", \"http://127.0.0.1:*\");\n\n  if (manifest.manifest_version === 3) {\n    manifest.content_security_policy ??= {};\n    manifest.content_security_policy.extension_pages = csp.toString();\n  } else {\n    manifest.content_security_policy = csp.toString();\n  }\n}\n","export const MANIFEST_LOADER_PLUGIN_NAME = `web-extension:manifest`;\nexport const LABELED_STEP_PLUGIN_NAME = `web-extension:labeled-step`;\nexport const MULTIBUILD_COMPLETE_PLUGIN_NAME = `web-extension:multibuild`;\nexport const BUNDLE_TRACKER_PLUGIN_NAME = `web-extension:bundle-tracker`;\nexport const HMR_REWRITE_PLUGIN_NAME = `web-extension:hmr-rewrite`;\n","import { MANIFEST_LOADER_PLUGIN_NAME } from \"./constants\";\n\nexport interface Logger {\n  verbose(message: string): void;\n  log(message: string): void;\n  warn(message: string): void;\n  error(message: string, error: unknown): void;\n}\n\nexport let RESET = \"\\x1b[0m\";\nexport let BOLD = \"\\x1b[1m\";\nexport let DIM = \"\\x1b[2m\";\nexport let RED = \"\\x1b[91m\";\nexport let GREEN = \"\\x1b[92m\";\nexport let YELLOW = \"\\x1b[93m\";\nexport let BLUE = \"\\x1b[94m\";\nexport let VIOLET = \"\\x1b[95m\";\nexport let CYAN = \"\\x1b[96m\";\n\nexport function createLogger(\n  verbose?: boolean,\n  disableColor?: boolean\n): Logger {\n  if (disableColor) {\n    RESET = \"\";\n    BOLD = \"\";\n    DIM = \"\";\n    RED = \"\";\n    GREEN = \"\";\n    YELLOW = \"\";\n    BLUE = \"\";\n    VIOLET = \"\";\n    CYAN = \"\";\n  }\n  return {\n    verbose(message: string) {\n      if (!verbose) return;\n      console.debug(\n        message\n          .split(\"\\n\")\n          .map(\n            (line) =>\n              `  ${BOLD}${DIM}${MANIFEST_LOADER_PLUGIN_NAME}${RESET} ${line}`\n          )\n          .join(\"\\n\")\n      );\n    },\n    log(message: string) {\n      console.log(message);\n    },\n    warn(message: string) {\n      console.warn(\n        message\n          .split(\"\\n\")\n          .map(\n            (line) =>\n              `${BOLD}${YELLOW}[${MANIFEST_LOADER_PLUGIN_NAME}] WARN: ${line}${RESET}`\n          )\n          .join(\"\\n\")\n      );\n    },\n    error(message: string, err: unknown) {\n      console.error(\n        message\n          .split(\"\\n\")\n          .map(\n            (line) =>\n              `${BOLD}${RED}[${MANIFEST_LOADER_PLUGIN_NAME}] ERROR: ${line}${RESET}`\n          )\n          .join(\"\\n\")\n      );\n      console.error(err);\n    },\n  };\n}\n","import * as rollup from \"rollup\";\nimport { inspect } from \"util\";\nimport * as vite from \"vite\";\nimport { ProjectPaths, ResolvedOptions } from \"../options\";\nimport { labeledStepPlugin } from \"../plugins/labeled-step-plugin\";\nimport { BuildMode } from \"./BuildMode\";\nimport { MANIFEST_LOADER_PLUGIN_NAME } from \"../constants\";\nimport { colorizeFilename, getInputPaths, removePlugin } from \"../utils\";\nimport { BOLD, DIM, Logger, RESET, GREEN } from \"../logger\";\nimport { createMultibuildCompleteManager } from \"../plugins/multibuild-complete-plugin\";\nimport { bundleTrackerPlugin } from \"../plugins/bundle-tracker-plugin\";\nimport { getViteConfigsForInputs } from \"./getViteConfigsForInputs\";\nimport { hmrRewritePlugin } from \"../plugins/hmr-rewrite-plugin\";\nimport { BundleMap } from \"./renderManifest\";\n\ninterface RebuildOptions {\n  paths: ProjectPaths;\n  userConfig: vite.UserConfig;\n  resolvedConfig: vite.ResolvedConfig;\n  manifest: any;\n  mode: BuildMode;\n  onSuccess?: () => Promise<void> | void;\n}\n\nexport interface BuildContext {\n  /**\n   * Based on the user config and new manifest, rebuild all the entrypoints and update the bundle\n   * map.\n   */\n  rebuild(rebuildOptions: RebuildOptions): Promise<void>;\n  getBundles(): BundleMap;\n}\n\n/**\n * Keeps track of everything that needs to be build for the extension, and orchastraits the actual\n * building of each part of the extension.\n */\nexport function createBuildContext({\n  pluginOptions,\n  logger,\n}: {\n  pluginOptions: ResolvedOptions;\n  logger: Logger;\n}): BuildContext {\n  /**\n   * Tracks an each input path relative to the Vite root, to their output filename and a list of\n   * generated assets.\n   */\n  let bundles: BundleMap = {};\n  let activeWatchers: rollup.RollupWatcher[] = [];\n\n  async function getBuildConfigs({\n    paths,\n    userConfig,\n    resolvedConfig,\n    manifest,\n    onSuccess,\n    mode,\n  }: RebuildOptions) {\n    const entryConfigs = getViteConfigsForInputs({\n      paths,\n      manifest,\n      mode,\n      logger,\n      resolvedConfig,\n      additionalInputs: pluginOptions.additionalInputs,\n      baseHtmlViteConfig: pluginOptions.htmlViteConfig ?? {},\n      baseSandboxViteConfig: {},\n      baseScriptViteConfig: pluginOptions.scriptViteConfig ?? {},\n      baseOtherViteConfig: {},\n    });\n    const multibuildManager = createMultibuildCompleteManager(async () => {\n      // This prints before the manifest plugin continues in watch mode\n      if (mode == BuildMode.WATCH) printCompleted();\n      await onSuccess?.();\n    });\n    const totalEntries = entryConfigs.count;\n    const getForcedConfig = (buildOrderIndex: number) => ({\n      // We shouldn't clear the screen for these internal builds\n      clearScreen: false,\n      // Don't copy static assets for the lib builds - already done during manifest build\n      publicDir: false,\n      // Don't empty the outDir, this is handled in the parent build process\n      build: { emptyOutDir: false },\n      // Don't discover any vite.config.ts files in the root, all relevant config is already\n      // passed down. Allowing discovery can cause a infinite loop where the plugins are applied\n      // over and over again. See <https://github.com/aklinker1/vite-plugin-web-extension/issues/56>\n      configFile: false,\n      plugins: [\n        labeledStepPlugin(logger, totalEntries, buildOrderIndex, paths),\n        multibuildManager.plugin(),\n      ],\n    });\n    const finalConfigPromises = entryConfigs.all\n      .map<vite.InlineConfig>((entryConfig, i) =>\n        vite.mergeConfig(\n          vite.mergeConfig(entryConfig, userConfig),\n          getForcedConfig(i)\n        )\n      )\n      // Exclude this plugin from child builds to break recursion\n      .map(async (config): Promise<vite.InlineConfig> => {\n        const newPlugins = await removePlugin(\n          config.plugins,\n          MANIFEST_LOADER_PLUGIN_NAME\n        );\n        return { ...config, plugins: newPlugins };\n      });\n    return await Promise.all(finalConfigPromises);\n  }\n\n  function printSummary(\n    paths: ProjectPaths,\n    buildConfigs: vite.InlineConfig[]\n  ): void {\n    if (buildConfigs.length === 0) return;\n\n    const lines = [\"\", `${BOLD}Build Steps${RESET}`];\n    buildConfigs.forEach((config, i) => {\n      const input = config.build?.rollupOptions?.input ?? config.build?.lib;\n      if (!input) return;\n\n      const inputs = getInputPaths(paths, input);\n      if (inputs.length === 1) {\n        lines.push(\n          `  ${i + 1}. Building ${colorizeFilename(inputs[0])} indvidually`\n        );\n      } else {\n        lines.push(\n          `  ${i + 1}. Bundling ${inputs.length} entrypoints together:`\n        );\n        inputs.forEach((relativePath) =>\n          lines.push(`    ${DIM}•${RESET} ${colorizeFilename(relativePath)}`)\n        );\n      }\n    });\n\n    logger.log(lines.join(\"\\n\"));\n  }\n\n  function printCompleted() {\n    logger.log(`\\n${GREEN}✓${RESET} All steps completed.\\n`);\n  }\n\n  function waitForWatchBuildComplete(watcher: rollup.RollupWatcher) {\n    return new Promise<void>((res, rej) => {\n      watcher.addListener(\"event\", async (e) => {\n        switch (e.code) {\n          case \"END\":\n            res();\n            break;\n          case \"ERROR\":\n            rej(e.error);\n            break;\n        }\n      });\n    });\n  }\n\n  return {\n    async rebuild(rebuildOptions) {\n      const { paths, mode } = rebuildOptions;\n      await Promise.all(activeWatchers.map((watcher) => watcher.close()));\n      activeWatchers = [];\n\n      const buildConfigs = await getBuildConfigs(rebuildOptions);\n      if (pluginOptions.printSummary) printSummary(paths, buildConfigs);\n\n      // Print configs deep enough to include rollup inputs\n      logger.verbose(\"Final configs: \" + inspect(buildConfigs, undefined, 7));\n\n      for (const config of buildConfigs) {\n        const bundleTracker = bundleTrackerPlugin();\n        (config.plugins ??= []).push(bundleTracker);\n\n        const output = await vite.build(config);\n        if (\"addListener\" in output) {\n          activeWatchers.push(output);\n          // In watch mode, wait until it's built once\n          await waitForWatchBuildComplete(output);\n        }\n\n        // Save the bundle chunks\n        const input = config.build?.lib ?? config.build?.rollupOptions?.input;\n        if (input) {\n          const chunks = bundleTracker.getChunks() ?? [];\n          for (const file of getInputPaths(paths, input)) {\n            bundles[file] = chunks;\n          }\n        }\n      }\n      // This prints before the manifest plugin continues in build mode\n      if (mode === BuildMode.BUILD) {\n        printCompleted();\n      }\n    },\n    getBundles() {\n      return bundles;\n    },\n  };\n}\n","import { GREEN, RESET, CYAN, VIOLET } from \"./logger\";\nimport path from \"node:path\";\nimport * as rollup from \"rollup\";\nimport * as vite from \"vite\";\nimport { ProjectPaths } from \"./options\";\n\n/**\n * Returns the same array, but with null or undefined values removed.\n */\nexport function compact<T>(array: Array<T | undefined>): T[] {\n  return array.filter((item) => item != null) as T[];\n}\n\n/**\n * Returns the file path minus the `.[ext]` if present.\n */\nexport function trimExtension(filename: string): string;\nexport function trimExtension(filename: undefined): undefined;\nexport function trimExtension(filename: string | undefined): string | undefined;\nexport function trimExtension(\n  filename: string | undefined\n): string | undefined {\n  return filename?.replace(path.extname(filename), \"\");\n}\n\n/**\n * Color a filename based on Vite's bundle summary\n * - HTML green\n * - Assets violet\n * - Chunks cyan\n *\n * It's not a perfect match because sometimes JS files are assets, but it's good enough.\n */\nexport function colorizeFilename(filename: string) {\n  let color = CYAN;\n  if (filename.match(/\\.(html|pug)$/)) color = GREEN;\n  if (\n    filename.match(/\\.(css|scss|stylus|sass|png|jpg|jpeg|webp|webm|svg|ico)$/)\n  )\n    color = VIOLET;\n  return `${color}${filename}${RESET}`;\n}\n\n/**\n * This generates a set of utils to allow configuring rollup to not use any inputs. It works by\n * adding a virtual, empty JS file as an import, and removing it from the bundle output when\n * finished.\n */\nexport function defineNoRollupInput() {\n  const tempId = \"virtual:temp.js\";\n  const tempResolvedId = \"\\0\" + tempId;\n  const tempContent = \"export const temp = true;\";\n\n  return {\n    /**\n     * Config used to ensure no inputs are required.\n     */\n    config: <vite.UserConfig>{\n      build: {\n        lib: {\n          entry: tempId,\n          formats: [\"es\"], // ES is the most minimal format. Since this is excluded from the bundle, this doesn't matter\n          name: tempId,\n          fileName: tempId,\n        },\n      },\n    },\n    /**\n     * Handle resolving the temp entry id.\n     */\n    resolveId(id: string) {\n      if (id.includes(tempId)) return tempResolvedId;\n    },\n    /**\n     * Handle loading a non-empty, basic JS script for the temp input\n     */\n    load(id: string) {\n      if (id === tempResolvedId) return tempContent;\n    },\n    /**\n     * Remove the temporary input from the final bundle.\n     */\n    cleanupBundle(bundle: rollup.OutputBundle) {\n      const tempAsset =\n        Object.entries(bundle).find(\n          ([_, asset]) =>\n            asset.type === \"chunk\" && asset.facadeModuleId === tempResolvedId\n        ) ?? [];\n      if (tempAsset?.[0] && bundle[tempAsset[0]]) delete bundle[tempAsset[0]];\n    },\n  };\n}\n\n// TODO: Test\nexport function getRootDir(config: vite.ResolvedConfig): string {\n  const cwd = process.cwd();\n  const configFileDir = config.configFile\n    ? path.resolve(cwd, config.configFile)\n    : cwd;\n  return path.resolve(configFileDir, config.root);\n}\n\n/**\n * Returns the absolute path to the outDir based on the resolved Vite config.\n *\n * TODO: Test\n *\n * > Must be absolute or it doesn't work on Windows:\n * > https://github.com/aklinker1/vite-plugin-web-extension/issues/63\n */\nexport function getOutDir(config: vite.ResolvedConfig): string {\n  const { outDir } = config.build;\n  return path.resolve(getRootDir(config), outDir);\n}\n\n// TODO: Test\nexport function getPublicDir(config: vite.ResolvedConfig): string | undefined {\n  if (config.publicDir === \"\") return;\n  return path.resolve(getRootDir(config), config.publicDir ?? \"public\");\n}\n\n/**\n * Return all the input file paths relative to vite's root.\n */\nexport function getInputPaths(\n  paths: ProjectPaths,\n  input: rollup.InputOption | vite.LibraryOptions\n): string[] {\n  let inputs: string[];\n  if (typeof input === \"string\") inputs = [input];\n  else if (Array.isArray(input)) inputs = input;\n  else if (\"entry\" in input) inputs = [input.entry];\n  else inputs = Object.values(input);\n\n  return inputs.map((file) => {\n    if (path.isAbsolute(file)) return path.relative(paths.rootDir, file).replace(/\\\\/g, \"/\");\n    return file.replace(/\\\\/g, \"/\");\n  });\n}\n\n/**\n * Remove a plugin by name from a `Array<PluginOption | PluginOption[]>`. Leaves the structure the\n * same, just removes any plugins that have the same name\n */\nexport async function removePlugin(\n  plugins: Array<vite.PluginOption | vite.PluginOption[]> | undefined,\n  pluginNameToRemove: string\n): Promise<Array<vite.PluginOption | vite.PluginOption[]> | undefined> {\n  if (!plugins) return plugins;\n\n  const newPlugins: Array<vite.PluginOption | vite.PluginOption[]> = [];\n  for (const itemPromise of plugins) {\n    const item = await itemPromise;\n    if (Array.isArray(item))\n      newPlugins.push(await removePlugin(item, pluginNameToRemove));\n    else if (!item || item.name !== pluginNameToRemove) newPlugins.push(item);\n  }\n\n  return newPlugins;\n}\n\n/**\n * Resolves fields with the `{{browser}}.xyz` prefix on an object. Used to resolve the manifest's\n * fields.\n *\n * @param browser Specify which fields should be used. If `firefox` is passed, it will only keep `{{firefox}}.xyz` values.\n * @param object The object who's fields need resolved. Can be a string, object, or array.\n * @returns The object, but will all it's deeply nested fields that begin with `{{..}}.` resolved.\n */\nexport function resolveBrowserTagsInObject(\n  browser: string | undefined,\n  object: any\n): any {\n  if (Array.isArray(object)) {\n    return object\n      .map((item) => resolveBrowserTagsInObject(browser, item))\n      .filter((item) => !!item);\n  } else if (typeof object === \"object\") {\n    return Object.keys(object).reduce((newObject, key) => {\n      if (!key.startsWith(\"{{\") || key.startsWith(`{{${browser}}}.`)) {\n        // @ts-expect-error: bad key typing\n        newObject[key.replace(`{{${browser}}}.`, \"\")] =\n          resolveBrowserTagsInObject(browser, object[key]);\n      }\n      return newObject;\n    }, {});\n  } else if (typeof object === \"string\") {\n    if (!object.startsWith(\"{{\") || object.startsWith(`{{${browser}}}.`)) {\n      return object.replace(`{{${browser}}}.`, \"\");\n    }\n    return undefined;\n  } else {\n    return object;\n  }\n}\n\nexport function withTimeout<T>(\n  promise: Promise<T>,\n  duration: number\n): Promise<T> {\n  return new Promise((res, rej) => {\n    const timeout = setTimeout(() => {\n      rej(`Promise timed out after ${duration}ms`);\n    }, duration);\n    promise\n      .then(res)\n      .catch(rej)\n      .finally(() => clearTimeout(timeout));\n  });\n}\n\n/**\n * Given any kind of entry file (name or path), return the file (name or path) vite will output\n */\nexport function getOutputFile(file: string): string {\n  return file\n    .replace(/\\.(pug)$/, \".html\")\n    .replace(/\\.(scss|stylus|sass)$/, \".css\")\n    .replace(/\\.(jsx|ts|tsx)$/, \".js\");\n}\n","import * as vite from \"vite\";\nimport { LABELED_STEP_PLUGIN_NAME } from \"../constants\";\nimport { Logger } from \"../logger\";\nimport { getInputPaths, colorizeFilename } from \"../utils\";\nimport { ProjectPaths } from \"../options\";\n\n/**\n * This plugin is in charge of logging all the steps (but not the summary).\n */\nexport function labeledStepPlugin(\n  logger: Logger,\n  total: number,\n  index: number,\n  paths: ProjectPaths\n): vite.Plugin {\n  let finalConfig: vite.ResolvedConfig;\n  let buildCount = 0;\n\n  function printFirstBuild() {\n    logger.log(\"\");\n\n    const progressLabel = `(${index + 1}/${total})`;\n    const input =\n      finalConfig.build?.rollupOptions?.input || finalConfig.build.lib;\n    if (!input) {\n      logger.warn(`Building unknown config ${progressLabel}`);\n      return;\n    }\n\n    const inputs = getInputPaths(paths, input);\n    logger.log(\n      `Building ${inputs.map(colorizeFilename).join(\", \")} ${progressLabel}`\n    );\n  }\n\n  function printRebuilds() {\n    const input = finalConfig.build?.rollupOptions?.input;\n    if (input == null) {\n      logger.warn(\"Rebuilding unknown config\");\n      return;\n    }\n\n    const files = getInputPaths(paths, input);\n    logger.log(`Rebuilding ${files.map(colorizeFilename).join(\", \")}`);\n  }\n\n  return {\n    name: LABELED_STEP_PLUGIN_NAME,\n    configResolved(config) {\n      finalConfig = config;\n      if (buildCount == 0) printFirstBuild();\n      else printRebuilds();\n\n      buildCount++;\n    },\n  };\n}\n","import * as vite from \"vite\";\nimport { MULTIBUILD_COMPLETE_PLUGIN_NAME } from \"../constants\";\nimport Lock from \"async-lock\";\n\n/**\n * Generate plugins that track how many builds are in progress at a single time, and their statuses\n * (error or success). After no more builds are running, and all builds have a success status,\n * the `onBuildsSucceeded` callback will be invoked.\n */\nexport function createMultibuildCompleteManager(\n  onBuildsSucceeded: () => Promise<void> | void\n) {\n  let activeBuilds = 0;\n  const buildStatuses: { [buildId: number]: Error } = {};\n  let nextBuildId = 0;\n  let hasTriggeredCallback = false;\n\n  const lock = new Lock();\n  const lockKey = \"builds\";\n\n  function incrementBuildCount(buildId: number) {\n    return lock.acquire(lockKey, () => {\n      activeBuilds++;\n      hasTriggeredCallback = false;\n      delete buildStatuses[buildId];\n    });\n  }\n  function decreaseBuildCount(buildId: number, err: Error | undefined) {\n    return lock.acquire(lockKey, async () => {\n      activeBuilds--;\n      if (err == null) delete buildStatuses[buildId];\n      else buildStatuses[buildId] = err;\n    });\n  }\n  /**\n   * Make sure the builds are completed and there are no errors, then call the callback.\n   */\n  function checkCompleted() {\n    return lock.acquire(lockKey, async () => {\n      if (\n        activeBuilds === 0 &&\n        Object.values(buildStatuses).length === 0 &&\n        !hasTriggeredCallback\n      ) {\n        hasTriggeredCallback = true;\n        await onBuildsSucceeded();\n      }\n    });\n  }\n\n  return {\n    plugin(): vite.Plugin {\n      const buildId = nextBuildId++;\n      // Increment initially because we know there is a build queued up\n      incrementBuildCount(buildId);\n      let hasBuildOnce = false;\n      return {\n        name: MULTIBUILD_COMPLETE_PLUGIN_NAME,\n        enforce: \"post\",\n        async buildStart() {\n          // Skip incrementing the first time since we already did it when the plugin was created\n          if (hasBuildOnce) await incrementBuildCount(buildId);\n          hasBuildOnce = true;\n        },\n        /**\n         * This hook is called regardless of if the build threw an error, so it's the only reliable\n         * place that can decrement the build counter regardless of build success.\n         */\n        async buildEnd(err) {\n          await decreaseBuildCount(buildId, err);\n        },\n        /**\n         * Call the completed callback AFTER the bundle has closed, so output files have been\n         * written to the disk.\n         *\n         * This is only called on success. Only when the SLOWEST build finishes on success. So we\n         * still need to check to make sure all builds have finished and were successful. We also\n         * only want to cal the callback from one of the plugin instances, not all of them. So we\n         * only call the callback from the first plugin instance that finished.\n         */\n        async closeBundle() {\n          await checkCompleted();\n        },\n      };\n    },\n  };\n}\n","import * as rollup from \"rollup\";\nimport * as vite from \"vite\";\nimport { BUNDLE_TRACKER_PLUGIN_NAME } from \"../constants\";\n\nexport interface BundleTrackerPlugin extends vite.Plugin {\n  getChunks(): string[] | undefined;\n}\n\n/**\n * A plugin that tracks and saves the output bundle.\n *\n * When rendering the final manifest, we need to add any files the inputs generated, and the chunks\n * return by this plugin are used to get the generated files.\n */\nexport function bundleTrackerPlugin(): BundleTrackerPlugin {\n  let chunks: string[] | undefined;\n  return {\n    name: BUNDLE_TRACKER_PLUGIN_NAME,\n    buildStart() {\n      chunks = undefined;\n    },\n    writeBundle(_, bundle) {\n      chunks = Object.values(bundle).map((chunk) => chunk.fileName);\n    },\n    getChunks: () => chunks,\n  };\n}\n","import path from \"node:path\";\nimport * as vite from \"vite\";\nimport { V } from \"vitest/dist/global-fe52f84b\";\nimport type browser from \"webextension-polyfill\";\nimport { Logger } from \"../logger\";\nimport { ProjectPaths, Manifest } from \"../options\";\nimport { hmrRewritePlugin } from \"../plugins/hmr-rewrite-plugin\";\nimport { compact, trimExtension } from \"../utils\";\nimport { BuildMode } from \"./BuildMode\";\n\nconst HTML_ENTRY_REGEX = /\\.(html)$/;\nconst SCRIPT_ENTRY_REGEX = /\\.(js|ts|mjs|mts)$/;\n\nclass CombinedViteConfigs {\n  /**\n   * A single config that builds all the HTML pages.\n   */\n  html?: vite.InlineConfig;\n  /**\n   * A single config that builds all the HTML pages for sandbox. These are separate from `html`\n   * because we want to properly tree-shake out any browser API usages, since those APIs aren't\n   * available in sandbox pages.\n   */\n  sandbox?: vite.InlineConfig;\n  /**\n   * All other JS inputs from the manifest and additional inputs are separated into their own\n   * configs.\n   *\n   * Unlike tsup, Vite cannot be given multiple entry-points, and produce individual bundles for\n   * each entrypoint. Vite can only produce code-split outputs that share other files, which\n   * extensions cannot consume. So we build each of these separately.\n   */\n  scripts?: vite.InlineConfig[];\n  /**\n   * Similar to scripts, but for other file \"types\". Sometimes CSS, SCSS, JSON, images, etc, can be\n   * passed into Vite directly. The most common case of this in extensions are CSS files listed for\n   * content scripts.\n   */\n  other?: vite.InlineConfig[];\n\n  /**\n   * The total number of configs required to build the extension.\n   */\n  get count(): number {\n    return this.all.length;\n  }\n\n  /**\n   * Return all the configs as an array.\n   */\n  get all(): vite.InlineConfig[] {\n    return compact([this.html, this.sandbox, this.scripts, this.other].flat());\n  }\n\n  applyBaseConfig(baseConfig: vite.InlineConfig) {\n    if (this.html) this.html = vite.mergeConfig(baseConfig, this.html);\n    if (this.sandbox) this.sandbox = vite.mergeConfig(baseConfig, this.sandbox);\n    this.scripts = this.scripts?.map((config) =>\n      vite.mergeConfig(baseConfig, config)\n    );\n    this.other = this.other?.map((config) =>\n      vite.mergeConfig(baseConfig, config)\n    );\n  }\n}\n\n/**\n * Given an input `manifest.json` with source code paths and `options.additionalInputs`, return a\n * set of Vite configs that can be used to build all the entry-points for the extension.\n */\nexport function getViteConfigsForInputs(options: {\n  paths: ProjectPaths;\n  mode: BuildMode;\n  additionalInputs: string[];\n  manifest: Manifest;\n  logger: Logger;\n  resolvedConfig: vite.ResolvedConfig;\n  baseHtmlViteConfig: vite.InlineConfig;\n  baseSandboxViteConfig: vite.InlineConfig;\n  baseScriptViteConfig: vite.InlineConfig;\n  baseOtherViteConfig: vite.InlineConfig;\n}): CombinedViteConfigs {\n  const { paths, additionalInputs, manifest, mode, logger, resolvedConfig } =\n    options;\n  const configs = new CombinedViteConfigs();\n\n  const processedInputs = new Set<string>();\n  const hasBeenProcessed = (input: string) => processedInputs.has(input);\n\n  /**\n   * For a list of entry-points, build them all in multi-page mode:\n   * <https://vitejs.dev/guide/build.html#multi-page-app>\n   */\n  function getMultiPageConfig(\n    entries: string[],\n    baseConfig: vite.InlineConfig\n  ): vite.InlineConfig | undefined {\n    const newEntries = entries.filter((entry) => !hasBeenProcessed(entry));\n    newEntries.forEach((entry) => processedInputs.add(entry));\n\n    if (newEntries.length === 0) return;\n\n    const plugins =\n      mode === BuildMode.DEV\n        ? [\n            hmrRewritePlugin({\n              server: resolvedConfig.server,\n              hmr:\n                typeof resolvedConfig.server.hmr === \"object\"\n                  ? resolvedConfig.server.hmr\n                  : undefined,\n              paths,\n              logger,\n            }),\n          ]\n        : [];\n\n    const inputConfig: vite.InlineConfig = {\n      plugins,\n      build: {\n        rollupOptions: {\n          input: newEntries.reduce<Record<string, string>>((input, entry) => {\n            input[trimExtension(entry)] = path.resolve(paths.rootDir, entry);\n            return input;\n          }, {}),\n          output: {\n            // Configure the output filenames so they appear in the same folder\n            // - popup/index.html\n            // - popup/index.js\n            entryFileNames: `[name].js`,\n            chunkFileNames: `[name].js`,\n            /**\n             * [name] for assetFileNames is either the filename or whole path. So if you\n             * have two `index.html` files in different directories, they would overwrite each\n             * other as `dist/index.css`.\n             *\n             * See [#47](https://github.com/aklinker1/vite-plugin-web-extension/issues/47) for\n             * more details.\n             */\n            assetFileNames: ({ name }) => {\n              if (!name) return \"[name].[ext]\";\n\n              if (name && path.isAbsolute(name)) {\n                name = path.relative(paths.rootDir, name);\n              }\n              return `${trimExtension(name)}.[ext]`;\n            },\n          },\n        },\n      },\n    };\n    return vite.mergeConfig(baseConfig, inputConfig);\n  }\n\n  /**\n   * For a given entry-point, get the vite config use to bundle it into a single file.\n   */\n  function getIndividualConfig(\n    entry: string,\n    baseConfig: vite.InlineConfig\n  ): vite.InlineConfig | undefined {\n    if (hasBeenProcessed(entry)) return;\n    processedInputs.add(entry);\n\n    /**\n     * \"content-scripts/some-script/index\" -> \"content-scripts/some-script/\"\n     * \"some-script\" -> \"\"\n     */\n    const moduleId = trimExtension(entry);\n    const inputConfig: vite.InlineConfig = {\n      build: {\n        watch: mode !== BuildMode.BUILD ? {} : undefined,\n        lib: {\n          name: \"_\",\n          entry,\n          formats: [\"iife\"],\n          fileName: () => moduleId + \".js\",\n        },\n      },\n    };\n    return vite.mergeConfig(baseConfig, inputConfig);\n  }\n\n  function getHtmlConfig(entries: string[]): vite.InlineConfig | undefined {\n    return getMultiPageConfig(entries, options.baseHtmlViteConfig);\n  }\n  function getSandboxConfig(entries: string[]): vite.InlineConfig | undefined {\n    return getMultiPageConfig(entries, options.baseSandboxViteConfig);\n  }\n  function getScriptConfig(entry: string): vite.InlineConfig | undefined {\n    return getIndividualConfig(entry, options.baseScriptViteConfig);\n  }\n  function getOtherConfig(entry: string): vite.InlineConfig | undefined {\n    return getIndividualConfig(entry, options.baseOtherViteConfig);\n  }\n\n  const {\n    htmlAdditionalInputs,\n    otherAdditionalInputs,\n    scriptAdditionalInputs,\n  } = separateAdditionalInputs(additionalInputs);\n\n  // HTML Pages\n  const htmlEntries = simplifyEntriesList([\n    manifest.action?.default_popup,\n    manifest.devtools_page,\n    manifest.options_page,\n    manifest.options_ui?.page,\n    manifest.browser_action?.default_popup,\n    manifest.page_action?.default_popup,\n    manifest.sidebar_action?.default_panel,\n    manifest.background?.page,\n    manifest.chrome_url_overrides?.bookmarks,\n    manifest.chrome_url_overrides?.history,\n    manifest.chrome_url_overrides?.newtab,\n    manifest.chrome_settings_overrides?.homepage,\n    htmlAdditionalInputs,\n  ]);\n  const sandboxEntries = simplifyEntriesList([manifest.sandbox?.pages]);\n\n  configs.html = getHtmlConfig(htmlEntries);\n  configs.sandbox = getSandboxConfig(sandboxEntries);\n\n  // Scripts\n  compact(\n    simplifyEntriesList([\n      manifest.background?.service_worker,\n      manifest.background?.scripts,\n      manifest.content_scripts?.flatMap(\n        (cs: browser.Manifest.ContentScript) => cs.js\n      ),\n      scriptAdditionalInputs,\n    ]).map(getScriptConfig)\n  ).forEach((scriptConfig) => {\n    configs.scripts ??= [];\n    configs.scripts.push(scriptConfig);\n  });\n\n  // Other Types\n  compact(\n    simplifyEntriesList([\n      manifest.content_scripts?.flatMap(\n        (cs: browser.Manifest.ContentScript) => cs.css\n      ),\n      otherAdditionalInputs,\n    ]).map(getOtherConfig)\n  ).forEach((otherConfig) => {\n    configs.other ??= [];\n    configs.other.push(otherConfig);\n  });\n\n  validateCombinedViteConfigs(configs);\n  return configs;\n}\n\n/**\n * `options.additionalInputs` accepts html files, scripts, and other file entry-points. This method\n * breaks those apart into their related groups (html, script, other).\n *\n * All `.html` files are\n */\nfunction separateAdditionalInputs(additionalInputs: string[]) {\n  const scriptAdditionalInputs: string[] = [];\n  const otherAdditionalInputs: string[] = [];\n  const htmlAdditionalInputs: string[] = [];\n\n  additionalInputs?.forEach((input) => {\n    if (HTML_ENTRY_REGEX.test(input)) htmlAdditionalInputs.push(input);\n    else if (SCRIPT_ENTRY_REGEX.test(input)) scriptAdditionalInputs.push(input);\n    else scriptAdditionalInputs.push(input);\n  });\n\n  return {\n    scriptAdditionalInputs,\n    otherAdditionalInputs,\n    htmlAdditionalInputs,\n  };\n}\n\n/**\n * Take in a list of any combination of single entries, lists of entries, or undefined and return a\n * single, simple list of all the truthy entry-points.\n */\nfunction simplifyEntriesList(\n  a: Array<string | string[] | undefined> | undefined\n): string[] {\n  return compact<string>(a?.flat() ?? []);\n}\n\nfunction validateCombinedViteConfigs(configs: CombinedViteConfigs) {\n  if (configs.count === 0) {\n    throw Error(\n      \"No inputs found in manifest.json. Run Vite with `--debug` for more details.\"\n    );\n  }\n}\n","/**\n * This plugin is responsible for rewriting the entry HTML files to point towards the dev server.\n */\nimport {\n  HmrOptions,\n  InlineConfig,\n  mergeConfig,\n  Plugin,\n  ServerOptions,\n} from \"vite\";\nimport { HMR_REWRITE_PLUGIN_NAME } from \"../constants\";\nimport { parseHTML } from \"linkedom\";\nimport path from \"path\";\nimport { ProjectPaths } from \"../options\";\nimport { Logger } from \"../logger\";\nimport { inspect } from \"util\";\n\nexport function hmrRewritePlugin(config: {\n  /**\n   * The resolved config.server options for the dev server vite build\n   */\n  server: ServerOptions;\n  /**\n   * The resolved config.server.hmr options for the dev server vite build\n   */\n  hmr: HmrOptions | undefined;\n  paths: ProjectPaths;\n  logger: Logger;\n}): Plugin {\n  const { hmr, server, paths, logger } = config;\n  let inputIds: string[] = [];\n\n  // Coped from node_modules/vite, do a global search for: vite:client-inject\n  function serializeDefine(define: any): string {\n    let res = `{`;\n    for (const key in define) {\n      const val = define[key];\n      res += `${JSON.stringify(key)}: ${\n        typeof val === \"string\" ? `(${val})` : JSON.stringify(val)\n      }, `;\n    }\n    return res + `}`;\n  }\n\n  return {\n    name: HMR_REWRITE_PLUGIN_NAME,\n\n    config(config) {\n      inputIds = Object.values(config.build?.rollupOptions?.input ?? {});\n\n      const hmrConfig: InlineConfig = {\n        server: {\n          hmr: {\n            protocol: \"http:\",\n            host: \"127.0.0.1\",\n            port: 5173,\n          },\n        },\n        define: {\n          // Coped from node_modules/vite, do a global search for: vite:client-inject\n          // These are used in node_modules/vite/dist/client/client.mjs, check there to see if a var\n          // can be null or not.\n          __MODE__: JSON.stringify(config.mode || null),\n          __BASE__: JSON.stringify(server.base || \"/\"),\n          __DEFINES__: serializeDefine(config.define || {}),\n          __SERVER_HOST__: JSON.stringify(server.host || \"localhost\"),\n          __HMR_PROTOCOL__: JSON.stringify(hmr?.protocol || null),\n          __HMR_HOSTNAME__: JSON.stringify(hmr?.host || \"localhost\"),\n          __HMR_PORT__: JSON.stringify(hmr?.clientPort || hmr?.port || 5173),\n          __HMR_DIRECT_TARGET__: JSON.stringify(\n            `${server.host ?? \"localhost\"}:${server.port ?? 5173}${\n              config.base || \"/\"\n            }`\n          ),\n          __HMR_BASE__: JSON.stringify(server.base ?? \"/\"),\n          __HMR_TIMEOUT__: JSON.stringify(hmr?.timeout || 30000),\n          __HMR_ENABLE_OVERLAY__: JSON.stringify(hmr?.overlay !== false),\n        },\n      };\n      return mergeConfig(config, hmrConfig);\n    },\n    transform(code, id) {\n      // Only transform HTML inputs\n      if (!id.endsWith(\".html\") || !inputIds.includes(id)) return;\n\n      const baseUrl = \"http://localhost:5173\";\n\n      // Load scripts from dev server\n      const { document } = parseHTML(code);\n\n      const pointToDevServer = (querySelector: string, attr: string): void => {\n        document.querySelectorAll(querySelector).forEach((element) => {\n          const src = element.getAttribute(attr);\n          if (!src) return;\n\n          const before = element.outerHTML;\n\n          if (path.isAbsolute(src)) {\n            element.setAttribute(attr, baseUrl + src);\n          } else if (src.startsWith(\".\")) {\n            const abs = path.resolve(path.dirname(id), src);\n            const pathname = path.relative(paths.rootDir, abs);\n            element.setAttribute(attr, `${baseUrl}/${pathname}`);\n          }\n\n          const after = element.outerHTML;\n          if (before !== after) {\n            logger.verbose(\n              \"Transformed for dev mode: \" + inspect({ before, after })\n            );\n          }\n        });\n      };\n\n      pointToDevServer(\"script[type=module]\", \"src\");\n      pointToDevServer(\"link[rel=stylesheet]\", \"href\");\n\n      // Add vite client to page\n      const clientScript = document.createElement(\"script\");\n      clientScript.type = \"module\";\n      clientScript.src = `${baseUrl}/@vite/client`;\n      document.head.append(clientScript);\n\n      // Return new HTML\n      return document.toString();\n    },\n  };\n}\n","import { ProjectPaths, ResolvedOptions } from \"../options\";\nimport { Logger } from \"../logger\";\nimport { ExtensionRunner } from \"./interface\";\nimport * as webExtLogger from \"web-ext/util/logger\";\nimport webExt, { WebExtRunInstance } from \"web-ext\";\nimport { inspect } from \"node:util\";\nimport { loadConfig as loadFsConfig } from \"../config\";\n\n/**\n * Create an implementation of the `ExtensionRunner` interface that uses `web-ext` to run the\n * extension during development.\n */\nexport function createWebExtRunner(\n  options: WebExtRunnerOptions\n): ExtensionRunner {\n  const { pluginOptions, paths, logger } = options;\n\n  let runner: WebExtRunInstance;\n\n  return {\n    async openBrowser() {\n      // Use the plugin's logger instead of web-ext's built-in one.\n      webExtLogger.consoleStream.write = ({ level, msg, name }) => {\n        if (level >= ERROR_LOG_LEVEL) logger.error(name, msg);\n        if (level >= WARN_LOG_LEVEL) logger.warn(msg);\n      };\n\n      const config = await loadConfig({ pluginOptions, logger, paths });\n      logger.verbose(\"web-ext config:\" + inspect(config));\n      const target =\n        pluginOptions.browser === null || pluginOptions.browser === \"firefox\"\n          ? null\n          : \"chromium\";\n\n      const sourceDir = paths.outDir;\n\n      runner = await webExt.cmd.run(\n        {\n          ...config,\n          target,\n          sourceDir,\n          // The plugin handles reloads, so disable auto-reload behaviors in web-ext\n          noReload: true,\n          noInput: true,\n        },\n        {\n          // Don't call `process.exit(0)` after starting web-ext\n          shouldExitProgram: false,\n        }\n      );\n    },\n\n    async reload() {\n      await runner.reloadAllExtensions();\n      logger.log(\"\"); // \"Last extension reload: ...\" log doesn't print a newline, so we need to add one.\n    },\n\n    async exit() {\n      return runner.exit();\n    },\n  };\n}\n\n// https://github.com/mozilla/web-ext/blob/e37e60a2738478f512f1255c537133321f301771/src/util/logger.js#L12\nconst WARN_LOG_LEVEL = 40;\nconst ERROR_LOG_LEVEL = 50;\n\nexport interface WebExtRunnerOptions {\n  pluginOptions: ResolvedOptions;\n  paths: ProjectPaths;\n  logger: Logger;\n}\n\nasync function loadConfig({\n  pluginOptions,\n  paths,\n  logger,\n}: {\n  pluginOptions: ResolvedOptions;\n  paths: ProjectPaths;\n  logger: Logger;\n}): Promise<any> {\n  const res = await loadFsConfig({\n    overrides: pluginOptions.webExtConfig,\n    paths,\n    logger,\n  });\n\n  logger.verbose(\"Config result: \" + inspect(res, undefined, 3));\n  return res.config;\n}\n","import JSON from \"json5\";\nimport YAML from \"yaml\";\nimport os from \"node:os\";\nimport { ProjectPaths } from \"./options\";\nimport path from \"node:path\";\nimport fs from \"node:fs/promises\";\nimport { Logger } from \"./logger\";\n\ntype ParserMap = Record<string, Array<{ parse: (text: string) => any }>>;\ninterface ConfigLayer {\n  file?: string;\n  config: any;\n}\n\nexport async function loadConfig({\n  paths,\n  logger,\n  overrides,\n}: {\n  overrides?: any;\n  paths: ProjectPaths;\n  logger: Logger;\n}): Promise<{\n  layers: ConfigLayer[];\n  config: any;\n}> {\n  const directories = Array.from(\n    new Set([paths.rootDir, process.cwd(), os.homedir()])\n  );\n  const parsers: ParserMap = {\n    \"\": [JSON, YAML],\n    \".json\": [JSON],\n    \".json5\": [JSON],\n    \".yml\": [YAML],\n    \".yaml\": [YAML],\n  };\n  const names = [\".webextrc\", \"webext.config\"];\n\n  const files: ParserMap = {};\n  directories.forEach((dir) => {\n    names.forEach((name) => {\n      Object.entries(parsers).forEach(([ext, parsers]) => {\n        files[path.resolve(dir, `${name}${ext}`)] = parsers;\n      });\n    });\n  });\n\n  const layers: ConfigLayer[] = [{ config: overrides ?? {} }];\n\n  for (const [file, parsers] of Object.entries(files)) {\n    parsersLoop: for (const parser of parsers) {\n      try {\n        const layer: ConfigLayer = { file, config: {} };\n        const text = await fs.readFile(file, \"utf-8\");\n        layer.config = parser.parse(text);\n        if (typeof layer.config !== \"object\")\n          throw Error(\"Config not an object\");\n        layers.push(layer);\n        break parsersLoop;\n      } catch (err) {\n        // noop, we don't care about failures\n      }\n    }\n  }\n\n  return {\n    layers,\n    config: layers\n      .map((layer) => layer.config)\n      .reduceRight((prevConfig, nextConfig) => {\n        return { ...prevConfig, ...nextConfig };\n      }),\n  };\n}\n","import { Logger } from \"./logger\";\nimport dns from \"node:dns\";\nimport https from \"node:https\";\nimport { inspect } from \"node:util\";\nimport Ajv from \"ajv\";\nimport { withTimeout } from \"./utils\";\n\nconst SCHEMA_URL = new URL(\"https://json.schemastore.org/chrome-manifest\");\n\nexport type ValidateManifest = (manifest: any | undefined) => Promise<void>;\n\n/**\n * Create a service that validate's your manifest.json's content.\n *\n * TODO: Unit test.\n */\nexport function createManifestValidator(options: {\n  logger: Logger;\n}): ValidateManifest {\n  const { logger } = options;\n  let schema: any | undefined;\n  const ajv = new Ajv();\n  // Some formats are not listed in the schema, so accept anything when they are seen.\n  ajv.addFormat(\"permission\", /.*/);\n  ajv.addFormat(\"content-security-policy\", /.*/);\n  ajv.addFormat(\"glob-pattern\", /.*/);\n  ajv.addFormat(\"match-pattern\", /.*/);\n  ajv.addFormat(\"mime-type\", /.*/);\n\n  function isOffline(): Promise<boolean> {\n    const isOffline = new Promise<boolean>((res) => {\n      dns.resolve(SCHEMA_URL.hostname, (err) => {\n        if (err == null) {\n          res(false);\n        } else {\n          logger.verbose(\"DNS not resolved\");\n          logger.verbose(inspect(err));\n          res(true);\n        }\n      });\n    });\n    return withTimeout(isOffline, 1e3).catch(() => true);\n  }\n\n  async function loadSchema() {\n    if (schema != null) return;\n    logger.verbose(`Loading JSON schema from ${SCHEMA_URL.href}...`);\n    schema = await get(SCHEMA_URL.href);\n  }\n\n  function get(url: string): Promise<any> {\n    return new Promise<any>((res, rej) => {\n      https\n        .get(url, (response) => {\n          let responseBody = \"\";\n          response.on(\"data\", (chunk) => {\n            responseBody += chunk;\n          });\n          response.on(\"end\", () => {\n            res(JSON.parse(responseBody));\n          });\n        })\n        .on(\"error\", (err) => rej(err));\n    });\n  }\n\n  return async (manifest) => {\n    if (schema == null && (await isOffline()))\n      return logger.warn(\n        \"Cannot connect to json.schemastore.org, skipping validation\"\n      );\n\n    logger.verbose(`Validating manifest...`);\n    if (manifest == null) throw Error(`Manifest cannot be ${manifest}`);\n    await loadSchema();\n    logger.verbose(`Loaded JSON schema: ${inspect(schema)}`);\n\n    const success = await ajv.validate(schema, manifest);\n    if (success) {\n      logger.verbose(\"Manifest is valid\");\n      return;\n    }\n\n    throw Error(\n      `Manifest is not valid: ${JSON.stringify(ajv.errors, null, 2)}`\n    );\n  };\n}\n","/**\n * Directive names that make up CSPs. There are more, this is all I need for the plugin.\n */\nexport type CspDirective = \"default-src\" | \"script-src\" | \"object-src\";\n\nexport class ContentSecurityPolicy {\n  private static DIRECTIVE_ORDER: Record<string, number | undefined> = {\n    \"default-src\": 0,\n    \"script-src\": 1,\n    \"object-src\": 2,\n  };\n\n  data: Record<string, string[]>;\n\n  constructor(csp?: string) {\n    if (csp) {\n      const sections = csp.split(\";\").map((section) => section.trim());\n      this.data = sections.reduce<Record<string, string[]>>((data, section) => {\n        const [key, ...values] = section.split(\" \").map((item) => item.trim());\n        if (key) data[key] = values;\n        return data;\n      }, {});\n    } else {\n      this.data = {};\n    }\n  }\n\n  /**\n   * Ensure a set of values are listed under a directive.\n   */\n  add(directive: CspDirective, ...newValues: string[]): ContentSecurityPolicy {\n    const values = this.data[directive] ?? [];\n    newValues.forEach((newValue) => {\n      if (!values.includes(newValue)) values.push(newValue);\n    });\n    this.data[directive] = values;\n    return this;\n  }\n\n  toString(): string {\n    const directives = Object.entries(this.data).sort(([l], [r]) => {\n      const lo = ContentSecurityPolicy.DIRECTIVE_ORDER[l] ?? 2;\n      const ro = ContentSecurityPolicy.DIRECTIVE_ORDER[r] ?? 2;\n      return lo - ro;\n    });\n    return directives.map((entry) => entry.flat().join(\" \")).join(\"; \") + \";\";\n  }\n}\n","import { Manifest } from \"webextension-polyfill\";\nimport { getOutputFile } from \"../utils\";\n\n/**\n * A map of the entrypoints listed in the manifest template to their output bundle filenames.\n */\nexport interface BundleMap {\n  [entry: string]: string[];\n}\n\n/**\n * Given a manifest with source code inputs, and a list of all the output files per build, output\n * the final manifest used by the browser.\n *\n * 1. Replace all inputs with their bundled outputs.\n * 2. If a content script output a CSS file, add the CSS file to the content script definition\n */\nexport function renderManifest(\n  input: any,\n  bundles: BundleMap\n): Manifest.WebExtensionManifest {\n  // Clone the input to the output.\n  const output: any = JSON.parse(JSON.stringify(input));\n\n  replaceEntrypoint(bundles, output.action, \"default_popup\");\n  replaceEntrypoint(bundles, output, \"devtools_page\");\n  replaceEntrypoint(bundles, output, \"options_page\");\n  replaceEntrypoint(bundles, output.options_ui, \"page\");\n  replaceEntrypoint(bundles, output.browser_action, \"default_popup\");\n  replaceEntrypoint(bundles, output.page_action, \"default_popup\");\n  replaceEntrypoint(bundles, output.sidebar_action, \"default_panel\");\n  replaceEntrypointArray(bundles, output.sandbox?.pages);\n  replaceEntrypoint(bundles, output.background, \"service_worker\");\n  replaceEntrypoint(bundles, output.background, \"page\");\n  replaceEntrypointArray(bundles, output.background?.scripts);\n\n  output.content_scripts?.forEach((cs: Manifest.ContentScript) => {\n    replaceEntrypointArray(bundles, cs.css);\n    replaceEntrypointArray(bundles, cs.js, (generated) => {\n      if (!generated.endsWith(\"css\")) return;\n\n      cs.css ??= [];\n      cs.css.push(generated);\n    });\n  });\n\n  return output;\n}\n\n/**\n * For the given entrypoint, return the replacement from the output, and all the other files that\n * were output.\n */\nfunction findReplacement(entry: string, bundles: BundleMap) {\n  const output = getOutputFile(entry);\n  const generatedFiles = bundles[entry];\n  if (generatedFiles == null)\n    throw Error(\"Render Manifest: Bundle output not found for: \" + entry);\n\n  const replacementIndex = generatedFiles.indexOf(output);\n  if (replacementIndex < 0)\n    throw Error(`Entrypoint output for ${entry} (${output}) not found`);\n\n  const [replacement] = generatedFiles.splice(replacementIndex, 1);\n  return {\n    replacement,\n    generatedFiles,\n  };\n}\n\nfunction replaceEntrypoint<T>(\n  bundles: BundleMap,\n  parent: T,\n  key: keyof NonNullable<T>,\n  onGeneratedFile?: (file: string) => void\n) {\n  const entry = parent?.[key] as string | undefined;\n  if (entry == null) return;\n\n  const { replacement, generatedFiles } = findReplacement(entry, bundles);\n  // @ts-expect-error\n  parent[key] = replacement;\n\n  if (onGeneratedFile) generatedFiles.forEach(onGeneratedFile);\n}\n\nfunction replaceEntrypointArray<T>(\n  bundles: BundleMap,\n  parent: T[] | undefined,\n  onGeneratedFile?: (file: string) => void\n) {\n  if (parent == null) return;\n\n  for (let i = 0; i < parent.length; i++) {\n    replaceEntrypoint(bundles, parent, i, onGeneratedFile);\n  }\n}\n"],"mappings":"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","names":["vite","import_util","vite","path","Lock","import_node_path","config","path","path","import_node_path","import_node_util","import_node_path","os","JSON","YAML","parsers","path","fs","loadConfig","webExt","import_node_util","Ajv","isOffline","dns","https","path","fs","import_fs_extra","fs"]}